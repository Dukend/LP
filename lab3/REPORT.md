#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Кондратьев Е.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для решения задач с определенным набором ситуаций, 
когда нужно перейти из начального состояния в конечное с помощью некоторых действий, 
очень удобно использовать язык логического программирования Prolog. 
В нем не нужно указывать, как получить желаемое значение, 
он указывает, что именно пользователь хочет получить. 
Если в задаче не так много состояний, 
то разница между этими двумя подходами будет незначительной. 
Однако для задач с большим количеством состояний очень сложно написать каждый путь, 
и Prolog, Mercury...(все логические языки) лучше всего подходят для таких задач.

## Задание

6. Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3
белых шара. Передвинуть черные шары на место белых, а белые - на
место черных. Шар можно передвинуть в соседнюю с ним пустую
лунку, либо в пустую лунку, находящуюся непосредственно за
ближайшим шаром. При этом черные шары можно передвигать
только вправо, а белые - только влево.

## Принцип решения

Предикат move, реализует сдвиг шаров в лунках. Создает два списка с начальным и конечным списком. 
```prolog 
move(In,Out):-
	append(S,['_','w'|T],In),
	append(S,['w','_'|T],Out).
move(In,Out):-
	append(S,['b','_'|T],In),
	append(S,['_','b'|T],Out).
move(In,Out):-
	append(S,['_','b','w'|T],In),
	append(S,['w','b','_'|T],Out).
move(In,Out):-
	append(S,['b','w','_'|T],In),
	append(S,['_','w','b'|T],Out).
``` 

Предикат продления пути с предотвращением петель.
```prolog
prolong([X|T],[Y,X|T]):-
	move(X,Y),
	not(member(Y,[X|T])).
```


Реализован предикат поиска в глубину. 
```prolog 
dfs([X|T],X,[X|T]).
dfs(P,X,R):-
	prolong(P,O),
	dfs(O,X,R).
```

Предикат для вывода результата поиска в глубину, времени его выполнения и длина самого решения
```prolog 
dfs_search(In,Out):-
	get_time(TimeStart),
	dfs([In],Out,Sub),
	get_time(TimeEnd),
	Time is TimeEnd - TimeStart,
	print(Sub),nl, nl,
	length(Sub, Len),write('Solution length: '),writeln(Len),
	write('Time:'),writeln(Time),nl.
```

Реализован предикат поиска в ширину.
```prolog 
bfs([[X|T]|_],X,[X|T]).
bfs([P|QI],X,R):-
	findall(W,prolong(P,W),T),
	append(QI,T,QO),
	bfs(QO,X,R).
```

Предикат для вывода результата поиска в ширину, времени его выполнения и длина самого решения
```prolog
bfs_search(In,Out):-
	get_time(TimeStart),
	bfs([[In]],Out,Sub),
	get_time(TimeEnd),
	Time is TimeEnd - TimeStart,
	print(Sub),nl, nl,
	length(Sub, Len),write('Solution length: '),writeln(Len),
	write('Time:'),writeln(Time),nl.
```

Предикат бесконечного вывода числа(N = 1, N++).
```prolog
int(1).
int(N):- int(M), N is M+1.
```


Реализован предикат поиска итерационном методом.
```prolog
iter([X|T],X,[X|T],0).
iter(P,X,R,N):-
	N>0, prolong(P,W),
	N1 is N-1,
	iter(W,X,R,N1).
```

Предикат для вывода результата поиска итерационном методом, времени его выполнения и длина самого решения. 
```prolog
iter_search(In,Out):-
	get_time(TimeStart),
	int(Level),
	(Level>100,!;iter([In],Out,Sub,Level)),
	get_time(TimeEnd), 
	Time is TimeEnd - TimeStart, 
	print(Sub),nl, nl,
	length(Sub, Len),write('Solution length: '),writeln(Len),
	write('Time:'),writeln(Time),nl.
```

Предикат вывода списка решения
```prolog
print([_]):-!.
print([B|T]):-
	print(T),nl,write(B).
```

2 предиката для быстрого просмотра итога моей лабораторной работы.
```prolog
solve:-
	In = ['b', 'b', 'b', 'b', '_', 'w', 'w', 'w'],
	Out = ['w', 'w', 'w', '_', 'b', 'b', 'b', 'b'],
	writeln('Iterative'),
	iter_search(In, Out),

	writeln('DFS'),
	dfs_search(In, Out),

	writeln('BFS'), 
	bfs_search(In,Out), 
	!.

solve(In,Out):-
	writeln('Iterative'),
	iter_search(In, Out),

	writeln('DFS'),
	dfs_search(In, Out),

	writeln('BFS'), 
	bfs_search(In,Out), 
	!.
```

## Результаты

```prolog
?- solve.
Iterative

[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]

Solution length: 20
Time:0.021905183792114258

DFS

[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
...
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]

Solution length: 20
Time:0.0008578300476074219

BFS

[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
...
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]

Solution length: 20
Time:0.004002094268798828

true.
```
! Алгоритм поиска | Длина найденного первым пути | Время работы | |-------------------------------------------------------------------| | В глубину | 20 | 0.004002094268798828 | | В ширину | 20 | 0.0008578300476074219 | | ID | 20 | 0.021905183792114258 |


## Выводы

По результатам работы данной лабораторной нельзя понять различия между поисками в глубину, в ширину и ID. Потому что все девево решений данной задачи имеет высоту 20, то есть каждый путь от началального условия к конечному состоит из 20 шагов. Логично, что поиск в глубину показал себя лучше, так как в отличии от остальных, ему не пришлось проходить по боковым веткам дерева запросов.
Однако различия все-таки были мною изучены из лекции Сошникова Д.В., а также web-ресурсов.
Очевидно, что логический язык для таких задач очень удобен. Действительно, у меня вызывает отваращение представлять написание решения данной задачи на императивном языке, зная простоту реализации на логическом.

Подводя итог, для разных задач подходят разные виды поиска, и выбор должен зависеть от цели. Когда память ограничена, лучше использовать поиск в глубину и поиск в ширину, чтобы найти кратчайший путь. Углубление итеративного поиска, позволяющее избежать экспоненциальной сложности, полезно только для самых простых задач. Конечно, лучше всего использовать эвристический поиск, что часто делается на практике. В отличие от алгоритмов, которые я использовал, эвристический поиск выполняет поиск в пространстве состояний более целенаправленно, поскольку он имеет функцию для оценки состояния.


