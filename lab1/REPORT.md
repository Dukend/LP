# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |          4    |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Одной из структур данных поддерживаемыми языком Prolog является список. Список в Prolog состоит из двух компонентов – головы и хвоста, где голова – первый элемент в списке, может являться как переменной, так и другим списком, хвост – оставшаяся часть списка, представляет из себя список (пустой или не пустой). 
В отличие от списков в императивных языках программирования в Prolog элементы списка могут быть абсолютно разными объектами. Кроме того, в императивных языках список – набор связанных между собой элементов, в Prolog – это бинарное дерево.
Навигацией в списке является рекурсивное разделение его на голову и хвост, за счет чего мы можем по нему перемещаться. В императивных языках иначе. Навигация происходит либо с помощью итераторов, либо при обращении по индексу.

## Задание 1.1: Предикат обработки списка

`replaceDukend(List, N, NewElem, Res)` - замена N-го элемента списка на указанный

`replace(List, N, NewElem, Res)` - замена N-го элемента списка на указанный

Примеры использования:
```prolog
?- replaceDukend([1,1,1,1,1], 2, qq, L).
L = [1, 1, qq, 1, 1].
?- replace([1,1,1,1,1],3,qw,L).
L = [1, 1, 1, qw, 1].
```

Реализация:
```prolog
% без стандартных
replaceDukend([_|L], 0, X, [X|L]).
replaceDukend([H|L], I, X, [H|L1]):-
	I > 0,
	N is I-1,
	replaceDukend(L, N, X, L1),
	!.
replaceDukend(L, _, _, L).

% со стандартными
replace(L, I, E, K) :-
	nth0(I, L, _, R),
	nth0(I, K, E, R).
replace(L, _, _, L).
```

`I`(индекс) - заменяет элемент на `X`, когда доходит до 0
когда не 0, уменьшается на 1 и идет дальше
после 0 вывод результата


## Задание 1.2: Предикат обработки числового списка

`morelessDukend(List, X, More, Less).` - разделение списка на два относительно первого элемента (по принципу "больше-меньше")

Примеры использования:
```prolog
?- morelessDukend([1,2,3,4,5], 3, More, Less).
More = [4, 5],
Less = [1, 2, 3] 
```

Реализация:
```prolog
morelessDukend([], _, [],[]):-!.
morelessDukend([H|L], X, [H|Lb], Lm):-
    H > X,
    morelessDukend(L, X, Lb, Lm).
morelessDukend([H|L], X, Lb, [H|Lm]):-
    morelessDukend(L, X, Lb, Lm).
```

проходит по списку `L` и передает в списки `Lb` и `Lm` значения списка, в `Lb` идут элементы больше элемента `X`, а  `Lm` идут элементы меньше или равные элементу `X`.

## Задание 1.3(6 пункт): Предикат обработки числового списка

Привести какой-нибудь содержательный пример совместного использования предикатов, реализованных в пунктах 3 и 4.

у моего говорящего предиката `wtf` странная, но имеющая право на жизнь функция

посмотрим

Примеры использования:
```prolog
?- wtf([1,2,3,4,6,7],5).
5
less: [6,7]
more: [2,3,4,1]
true 
```

Реализация:
```prolog
wtf(L,X):-
	appendDukend(L, [a], R),
	lengthDukend(R,N),
	replaceDukend(R,N-1,X,C),
	removeDukend(a,C,T), % тот самый предикат из 3 пункта(задание 1.1)
	morelessDukend(T,X,More,Less), % тот самый предикат из 4 пункта(задание 1.2)
	write(X), nl,
	write(less), write(': '),write(More), nl,
	write(more), write(': '),write(Less).
```
А теперь объясню
предикат `wtf` получает список и число,  дальше разбивает список на 2, один содержит элементы больше числа, другой - меньше числа

по самой работе:

добавляем бесполезный элемент в конец

находим длину списка

заменяем последний элемент предикатом из пункта 3 на наше число, которое разделит список

дальше как раз делим наш список предикатом из 4 пункта
 
а дальше более или менее красивый вывод нашего числа и 2ух списков 


## Задание 2: Реляционное представление данных

Для себя из преимуществ модели реляционного представления выделил то, что она сама по себе достаточно простая для понимания человеком. По недостаткам: для реализации даже простой функции иногда нужно сломать себе мозг.

Вариант 2.
1. `task1()` печатает средний балл для каждого предмета 
2. `task2()` для каждой группы находит количество не сдавших студентов
3. `task3()` находит количество не сдавших студентов для каждого из предметов

Запуск
```prolog
?- task1().
Логическое программирование: 3.9642857142857144
Математический анализ: 3.892857142857143
Функциональное программирование: 3.9642857142857144
Информатика: 3.9285714285714284
Английский язык: 3.75
Психология: 3.9285714285714284
true.

?- task2().
101: 2
104: 2
103: 3
102: 5
true.

?- task3().
Логическое программирование: 2
Математический анализ: 3
Функциональное программирование: 1
Информатика: 2
Английский язык: 4
Психология: 1
true.
```
Листинг
```prolog
% база
:- ['two.pl'].

% предикат для отчистки повторений в списке
withoutcopy([], []):-!.
withoutcopy([X|L], List):-
          member(X, L),
	  !, 
	  withoutcopy(L, List).
withoutcopy([X|L], [X|List]):-
	  !, 
	  withoutcopy(L, List).

% пункт 1 Напечатать средний балл для каждого предмета
task1():-
	findall(Sub, grade(_, _, Sub, _), S),
	withoutcopy(S, Subj),
	mark(Subj).
sum([],0).
sum([M|Marks],Sum):-
	sum(Marks,S),
	Sum is M + S.
mark([]).
mark([Subj|T]):-
	findall(Mark,grade(_,_,Subj,Mark),Marks),
	sum(Marks,M),
	length(Marks,Len),
	X is M / Len,
	write(Subj), write(': '), write(X), nl,
	mark(T).

%######################
%  пункт 2 Для каждой группы, найти количество не сдавших студентов
task2():-
	findall(Gr, grade(Gr, _, _, _), Group),
	withoutcopy(Group, G),
	pass(G).
pass([]).
pass([Group|T]):-
	findall(Stud,grade(Group,Stud,_,2),Studs),
	withoutcopy(Studs,S),
	length(S,X),
	write(Group), write(': '),write(X), nl,
	pass(T).

%######################
% пункт 3 Найти количество не сдавших студентов для каждого из предметов
task3():-
	findall(Sub, grade(_, _, Sub, _), S),
	withoutcopy(S, Subj),
	subj(Subj).
subj([]).
subj([Subj|T]):-
	findall(Stud,grade(_,Stud,Subj,2),Studs),
	length(Studs,X),
	write(Subj), write(': '), write(X), nl,
	subj(T).


```

task1: 
`находим все предметы`

`создаем список с предметами`

`далее рекурсия`

	`находим все оценки по предмету`
	
	`считаем сумму оценок`
	
	`далее находим среднее, деля сумму на длину списка оценок`
	
	`повторяем для следующего предмета`

task2:
`находим все группы`

`создаем список с группами`

`далее рекурсия`

	`находим всех студентов сдавших на 2`
	
	`выводим длину этого списка`
	
	`повторяем для следующей группы`

task3:
`находим все предметы`

`создаем список с предметами`

`далее рекурсия`

	`находим всех студентов сдавших на 2 этот предмет`
	
	`выводим длину этого списка`
	
	`повторяем для следующей предмета`

## Выводы

После выполнения первой лабы, осознаю, что использовать Пролог для повседневных задач не стоит, в обработке произвольной информации Пролог слаб, но в обработке подготовленных баз данных(grade(102,'Петров','Логическое программирование',4).) он мега эффективен и прост. 
Сама лаба дала понять, как думает Пролог, научила основам Пролога и волшебному предикату findall, который во многих моментах не заменим.
Плюсы: отсутствие типизации значений, удобство навигации в списках и удобная обработка баз данных, заданными специальными предикатами(grade(102,'Петров','Логическое программирование',4).)
В итоге, считаю, что Пролог чрезвычайно удобен, но в очень специфичных задачах.



